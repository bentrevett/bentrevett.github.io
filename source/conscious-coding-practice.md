# Conscious Coding Practice

<span class="date">2021-03-18</span>

Taken from Noah Gibbs' [talk](https://www.youtube.com/watch?v=NF4rHCUElVI).

Learning how to program from programming exercises, e.g. HackerRank, LeetCode, etc., is not ideal. However, once you've solved them, you've solved them, you constantly have to be finding new ones. Sometimes they rely on an algorithmic trick that you don't yet know, which makes them difficult. They're also only exercises in *how* to build something and not choosing *what* to build.

A better choice is "The Coding Study", by Noah Gibbs. The technique has three steps:

1. Pick a tool.
2. Pick a task.
3. Pick a purpose.
4. Write down how long you're going to work on it.
5. Work on it until the time runs out.
6. Reflect on how well, or badly, it went.

## Picking a Tool

You tool here is your language or library or both. It can be either the thing you want to learn or, more commonly, the thing you're using to do the learning.

## Picking a Task

Your task is what you want to build. There are two ways to choose a task:

1. The easy way: pick something simple, or that you've done before, or from a simple programming exercise from online.
2. The fun way: pick something in the world, anything, and turn it into a system of behavior.

## Pick a Purpose

This is the reason why you're building what you're building, and/or what you want to learn. If you're implementing an algorithm that uses recursion then your purpose is learning recursion, etc. There are two ways to choose a purpose:

1. What skill do you wish you had? Choose something that takes you one step in that direction.
2. Do something that scares you. Pick something that you can't do yet.
3. Pick the weirdest thing that might work, and do it.

## Seven Guidelines

1. Choose your tool, task and purpose *first*, before you begin coding. Make sure to *write* them out in words. This helps avoid feature creep.
2. Always stop at the end of the time limit. Without a time limit you either have long failures, where you don't learn much, or long successes, where you're still working on the problem but not actually learning anything.
3. Throw away the code after you've finished. If you have the goal of using it in production you won't learn as much as you're building to use, and not to learn.
4. Your purpose should be one idea, and no more. If your purpose is too complex then you won't learn anything.
5. Start your code simply and build up with layers. Reduces the time taken to start getting something working.
6. Use tasks from the real world. You'll be surprised by the hidden complexity, and it stops you recycling ideas that you already know.
7. Break the rules. Ignore these guidelines when it makes sense, or the rules to an extreme, e.g. set shorter and shorter time limits.

## Pairing

When doing pair programming make sure to brainstorm the idea and the interesting parts together. Have one person on the keyboard at once whilst the other debugs and designs.
