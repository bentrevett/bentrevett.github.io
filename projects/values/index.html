<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bradley-Terry Value Ranker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .comparison-area {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .option {
            flex: 1;
            min-width: 250px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }
        
        .option h2 {
            color: #495057;
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        .option p {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .stats {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .stats h3 {
            color: #495057;
            margin-bottom: 15px;
        }
        
        .progress {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        
        .btn:hover {
            background: #5a67d8;
        }
        
        .rankings {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .rankings h3 {
            color: #495057;
            margin-bottom: 15px;
        }
        
        .rank-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .rank-item:hover {
            transform: translateX(5px);
        }
        
        .rank-number {
            font-weight: bold;
            color: #667eea;
            margin-right: 15px;
        }
        
        .score {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .vs {
            font-size: 2em;
            color: #6c757d;
            align-self: center;
        }
        
        @media (max-width: 600px) {
            .comparison-area {
                flex-direction: column;
            }
            
            .vs {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Value Ranker</h1>
        
        <div class="stats">
            <div class="progress">
                <span>Comparisons made: <strong id="comparison-count">0</strong></span>
                <button class="btn" onclick="toggleRankings()">Show Rankings</button>
            </div>
        </div>
        
        <div class="comparison-area" id="comparison-area">
            <div class="option" onclick="choose(0)">
                <h2 id="option1">Loading...</h2>
                <p>Click to prefer this</p>
            </div>
            <span class="vs">VS</span>
            <div class="option" onclick="choose(1)">
                <h2 id="option2">Loading...</h2>
                <p>Click to prefer this</p>
            </div>
        </div>
        
        <div class="rankings" id="rankings" style="display: none;">
            <h3>Current Rankings</h3>
            <div id="rankings-list"></div>
        </div>
    </div>

    <script>
        // Hard-coded list of 25 items
         // Hard-coded list of values
        const items = [
            "Accountability",
            "Achievement",
            "Adaptability",
            "Adventure",
            "Altruism",
            "Ambition",
            "Authenticity",
            "Balance",
            "Beauty",
            "Being the best",
            "Belonging",
            "Career",
            "Caring",
            "Collaboration",
            "Commitment",
            "Community",
            "Compassion",
            "Competence",
            "Confidence",
            "Connection",
            "Contentment",
            "Contribution",
            "Cooperation",
            "Courage",
            "Creativity",
            "Curiosity",
            "Dignity",
            "Diversity",
            "Environment",
            "Efficiency",
            "Equality",
            "Ethics",
            "Excellence",
            "Fairness",
            "Faith",
            "Family",
            "Financial stability",
            "Forgiveness",
            "Freedom",
            "Friendship",
            "Fun",
            "Future generations",
            "Generosity",
            "Giving back",
            "Grace",
            "Gratitude",
            "Growth",
            "Harmony",
            "Health",
            "Home",
            "Honesty",
            "Hope",
            "Humility",
            "Humor",
            "Inclusion",
            "Independence",
            "Initiative",
            "Integrity",
            "Intuition",
            "Job security",
            "Joy",
            "Justice",
            "Kindness",
            "Knowledge",
            "Leadership",
            "Learning",
            "Legacy",
            "Leisure",
            "Love",
            "Loyalty",
            "Making a difference",
            "Nature",
            "Openness",
            "Optimism",
            "Order",
            "Parenting",
            "Patience",
            "Patriotism",
            "Peace",
            "Perseverance",
            "Personal fulfillment",
            "Power",
            "Pride",
            "Recognition",
            "Reliability",
            "Resourcefulness",
            "Respect",
            "Responsibility",
            "Risk-taking",
            "Safety",
            "Security",
            "Self-discipline",
            "Self-expression",
            "Self-respect",
            "Serenity",
            "Service",
            "Simplicity",
            "Spirituality",
            "Sportsmanship",
            "Stewardship",
            "Success",
            "Teamwork",
            "Thrift",
            "Time",
            "Tradition",
            "Travel",
            "Trust",
            "Truth",
            "Understanding",
            "Uniqueness",
            "Usefulness",
            "Vision",
            "Vulnerability",
            "Wealth",
            "Well-being",
            "Wholeheartedness",
            "Wisdom",
        ];
        
        // Initialize Bradley-Terry model data
        const wins = new Array(items.length).fill(0);
        const losses = new Array(items.length).fill(0);
        const comparisons = [];
        let currentPair = null;
        let comparisonCount = 0;
        
        // Cache for Bradley-Terry parameters
        let cachedParams = null;
        let cacheValid = false;
        
        // Lookup table for match counts
        const matchCountCache = new Map();
        
        function getMatchCount(i, j) {
            const key = i < j ? `${i},${j}` : `${j},${i}`;
            return matchCountCache.get(key) || 0;
        }
        
        function updateMatchCount(winner, loser) {
            const key = winner < loser ? `${winner},${loser}` : `${loser},${winner}`;
            matchCountCache.set(key, (matchCountCache.get(key) || 0) + 1);
        }
        
        // Bradley-Terry parameter estimation with regularization
        function estimateBradleyTerryParams(quickMode = false) {
            // Use cache if valid
            if (cacheValid && cachedParams && !quickMode) {
                return cachedParams;
            }
            
            const n = items.length;
            const params = new Array(n).fill(1);
            const pseudoCount = 0.5;
            
            // Fewer iterations for quick mode (selection phase)
            const iterations = quickMode ? 20 : 100;
            
            for (let iter = 0; iter < iterations; iter++) {
                const newParams = new Array(n).fill(0);
                
                for (let i = 0; i < n; i++) {
                    const regularizedWins = wins[i] + pseudoCount;
                    let denomSum = pseudoCount;
                    
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            const matchCount = getMatchCount(i, j);
                            if (matchCount > 0) {
                                denomSum += matchCount / (params[i] + params[j]);
                            }
                        }
                    }
                    
                    // Simplified regularization for unplayed matchups
                    const totalComparisons = wins[i] + losses[i];
                    if (totalComparisons < 3) {
                        denomSum += (3 - totalComparisons) * 0.1;
                    }
                    
                    newParams[i] = regularizedWins / denomSum;
                }
                
                // Normalize parameters
                const logSum = newParams.reduce((sum, p) => sum + Math.log(p), 0);
                const geoMean = Math.exp(logSum / n);
                
                for (let i = 0; i < n; i++) {
                    params[i] = newParams[i] / geoMean;
                }
            }
            
            // Cache the full calculation
            if (!quickMode) {
                cachedParams = params;
                cacheValid = true;
            }
            
            return params;
        }
        
        function showNewPair() {
            let idx1, idx2;
            let usingTopBias = false;
            
            // Track which items have been compared least
            const comparisonCounts = new Array(items.length).fill(0);
            for (const comp of comparisons) {
                comparisonCounts[comp.winner]++;
                comparisonCounts[comp.loser]++;
            }
            
            // Find items with fewest comparisons
            const minComparisons = Math.min(...comparisonCounts);
            const undercomparedItems = comparisonCounts
                .map((count, idx) => ({ idx, count }))
                .filter(item => item.count <= minComparisons + 1)
                .map(item => item.idx);
            
            // Strategy selection based on progress
            const avgComparisons = comparisonCount * 2 / items.length;
            
            if (avgComparisons < 1.5 || undercomparedItems.length > items.length * 0.3) {
                // Early phase or many undercompared items: Focus on coverage
                if (undercomparedItems.length >= 2 && Math.random() < 0.7) {
                    // 70% chance to compare undercompared items
                    idx1 = undercomparedItems[Math.floor(Math.random() * undercomparedItems.length)];
                    
                    // Remove idx1 from candidates for idx2
                    const remainingItems = undercomparedItems.filter(i => i !== idx1);
                    if (remainingItems.length > 0) {
                        idx2 = remainingItems[Math.floor(Math.random() * remainingItems.length)];
                    } else {
                        // Pair with random item
                        idx2 = Math.floor(Math.random() * items.length);
                        while (idx2 === idx1) {
                            idx2 = Math.floor(Math.random() * items.length);
                        }
                    }
                } else {
                    // Random selection for diversity
                    idx1 = Math.floor(Math.random() * items.length);
                    idx2 = Math.floor(Math.random() * items.length);
                    while (idx2 === idx1) {
                        idx2 = Math.floor(Math.random() * items.length);
                    }
                }
            } else if (comparisonCount >= 20 && Math.random() < 0.5) {
                // Later phase: Focus on refining top items
                usingTopBias = true;
                
                // Use quick mode for selection (fewer iterations)
                const params = estimateBradleyTerryParams(true);
                const rankedIndices = items.map((_, idx) => ({
                    idx: idx,
                    score: params[idx]
                })).sort((a, b) => b.score - a.score);
                
                // Pick one item from the top 5
                const topIdx = Math.floor(Math.random() * Math.min(5, items.length));
                idx1 = rankedIndices[topIdx].idx;
                
                // Weighted selection for opponent
                const weights = rankedIndices.map((item, rank) => {
                    if (item.idx === idx1) return 0;
                    
                    // Prefer similar-strength opponents
                    const rankDiff = Math.abs(rank - topIdx);
                    return Math.exp(-rankDiff / 15);
                });
                
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = 0; i < weights.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        idx2 = rankedIndices[i].idx;
                        break;
                    }
                }
                
                if (idx2 === undefined || idx2 === idx1) {
                    idx2 = Math.floor(Math.random() * items.length);
                    while (idx2 === idx1) {
                        idx2 = Math.floor(Math.random() * items.length);
                    }
                }
            } else {
                // Standard random selection
                idx1 = Math.floor(Math.random() * items.length);
                idx2 = Math.floor(Math.random() * items.length);
                while (idx2 === idx1) {
                    idx2 = Math.floor(Math.random() * items.length);
                }
            }
            
            currentPair = [idx1, idx2];
            
            // Randomly swap positions
            if (Math.random() < 0.5) {
                currentPair = [idx2, idx1];
            }
            
            document.getElementById('option1').textContent = items[currentPair[0]];
            document.getElementById('option2').textContent = items[currentPair[1]];
        }
        
        function choose(option) {
            if (!currentPair) return;
            
            const winner = currentPair[option];
            const loser = currentPair[1 - option];
            
            wins[winner]++;
            losses[loser]++;
            comparisons.push({ winner, loser });
            updateMatchCount(winner, loser);
            comparisonCount++;
            
            // Invalidate cache
            cacheValid = false;
            
            document.getElementById('comparison-count').textContent = comparisonCount;
            
            // Only update rankings if they're visible
            if (document.getElementById('rankings').style.display !== 'none') {
                updateRankings();
            }
            
            showNewPair();
        }
        
        function updateRankings() {
            const startTime = performance.now();
            
            const params = estimateBradleyTerryParams();
            const rankings = items.map((item, idx) => ({
                name: item,
                score: params[idx],
                wins: wins[idx],
                losses: losses[idx],
                total: wins[idx] + losses[idx]
            }));
            
            rankings.sort((a, b) => b.score - a.score);
            
            const computeTime = performance.now() - startTime;
            
            const rankingsList = document.getElementById('rankings-list');
            rankingsList.innerHTML = rankings.map((item, idx) => {
                // Confidence indicator based on number of comparisons
                let confidence = '';
                if (item.total === 0) {
                    confidence = '⚪'; // No data
                } else if (item.total === 1) {
                    confidence = '🔴'; // Very low confidence
                } else if (item.total <= 3) {
                    confidence = '🟡'; // Low confidence
                } else {
                    confidence = '🟢'; // Good confidence
                }
                
                return `
                <div class="rank-item">
                    <div>
                        <span class="rank-number">#${idx + 1}</span>
                        <span>${item.name}</span>
                        <span style="margin-left: 5px;">${confidence}</span>
                    </div>
                    <div>
                        <span class="score">Score: ${item.score.toFixed(2)} (${item.wins}W-${item.losses}L)</span>
                    </div>
                </div>
            `}).join('');
            
            // Add legend at the bottom
            if (!document.getElementById('confidence-legend')) {
                const legend = document.createElement('div');
                legend.id = 'confidence-legend';
                legend.style.cssText = 'margin-top: 20px; padding-top: 15px; border-top: 1px solid #e9ecef; font-size: 0.9em; color: #6c757d;';
                legend.innerHTML = `
                    <strong>Confidence:</strong><br>
                    🟢 Good (4+ comparisons)<br>
                    🟡 Low (2-3 comparisons)<br>
                    🔴 Very Low (1 comparison)<br>
                    ⚪ No data<br>
                    <br><span style="font-size: 0.8em;">Computed in ${computeTime.toFixed(1)}ms</span>
                `;
                document.getElementById('rankings').appendChild(legend);
            } else {
                // Update computation time
                const legend = document.getElementById('confidence-legend');
                const timeSpan = legend.querySelector('span[style*="font-size: 0.8em"]');
                if (timeSpan) {
                    timeSpan.textContent = `Computed in ${computeTime.toFixed(1)}ms`;
                }
            }
        }
        
        function toggleRankings() {
            const rankings = document.getElementById('rankings');
            const btn = document.querySelector('.btn');
            
            if (rankings.style.display === 'none') {
                // Update rankings when showing them
                updateRankings();
                rankings.style.display = 'block';
                btn.textContent = 'Hide Rankings';
            } else {
                rankings.style.display = 'none';
                btn.textContent = 'Show Rankings';
            }
        }
        
        // Initialize
        showNewPair();
    </script>
</body>
</html>